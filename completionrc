#!/bin/bash

[ -n "${BASH_COMPLETION_DEBUG:-}" ] && set -v || set +v


# Get the word to complete
# This is nicer than ${COMP_WORDS[$COMP_CWORD]}, since it handles cases
# where the user is completing in the middle of a word.
# (For example, if the line is "ls foobar",
# and the cursor is here -------->   ^
# it will complete just "foo", not "foobar", which is what the user wants.)
#
# Accepts an optional parameter indicating which characters out of
# $COMP_WORDBREAKS should NOT be considered word breaks. This is useful
# for things like scp where we want to return host:path and not only path.
_get_cword()
{
	local i
	local WORDBREAKS=${COMP_WORDBREAKS}
	if [ -n $1 ]; then
		for (( i=0; i<${#1}; ++i )); do
			local char=${1:$i:1}
			WORDBREAKS=${WORDBREAKS//$char/}
		done
	fi
	local cur=${COMP_LINE:0:$COMP_POINT}
	local tmp="${cur}"
	local word_start=`expr "$tmp" : '.*['"${WORDBREAKS}"']'`
	while [ "$word_start" -ge 2 ]; do
        	local char=${cur:$(( $word_start - 2 )):1}
		if [ "$char" != "\\" ]; then
			break
		fi
		tmp=${COMP_LINE:0:$(( $word_start - 2 ))}
		word_start=`expr "$tmp" : '.*['"${WORDBREAKS}"']'`
	done


	cur=${cur:$word_start}
	echo $cur
}


# This function completes on signal names
#
_signals()
{
	local i

	# standard signal completion is rather braindead, so we need
	# to hack around to get what we want here, which is to
	# complete on a dash, followed by the signal name minus
	# the SIG prefix
	COMPREPLY=( $( compgen -A signal SIG${cur#-} ))
	for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
		COMPREPLY[i]=-${COMPREPLY[i]#SIG}
	done
}

# This function completes on all available network interfaces
# -a: restrict to active interfaces only
# -w: restrict to wireless interfaces only
#
_available_interfaces()
{
	local cmd

	if [ "${1:-}" = -w ]; then
		cmd="iwconfig"
	elif [ "${1:-}" = -a ]; then
		cmd="ifconfig"
	else
		cmd="ifconfig -a"
	fi

	COMPREPLY=( $( eval $cmd 2>/dev/null | \
		sed -ne 's|^\('$cur'[^[:space:][:punct:]]\{1,\}\).*$|\1|p') )
}

# This function expands tildes in pathnames
#
_expand()
{
	[ "$cur" != "${cur%\\}" ] && cur="$cur\\"

	# expand ~username type directory specifications
	if [[ "$cur" == \~*/* ]]; then
		eval cur=$cur
		
	elif [[ "$cur" == \~* ]]; then
		cur=${cur#\~}
		COMPREPLY=( $( compgen -P '~' -u $cur ) )
		return ${#COMPREPLY[@]}
	fi
}

# This function completes on process IDs.
# AIX and Solaris ps prefers X/Open syntax.
[ $UNAME = SunOS -o $UNAME = AIX ] &&
_pids()
{
	COMPREPLY=( $( compgen -W '$( command ps -efo pid | sed 1d )' -- $cur ))
} ||
_pids()
{
	COMPREPLY=( $( compgen -W '$( command ps axo pid | sed 1d )' -- $cur ) )
}

# This function completes on process group IDs.
# AIX and SunOS prefer X/Open, all else should be BSD.
[ $UNAME = SunOS -o $UNAME = AIX ] &&
_pgids()
{
	COMPREPLY=( $( compgen -W '$( command ps -efo pgid | sed 1d )' -- $cur ))
} ||
_pgids()
{
	COMPREPLY=( $( compgen -W '$( command ps axo pgid | sed 1d )' -- $cur ))
}

# This function completes on user IDs
#
_uids()
{
	if type getent &>/dev/null; then
	    COMPREPLY=( $( getent passwd | \
			    awk -F: '{if ($3 ~ /^'$cur'/) print $3}' ) )
	elif type perl &>/dev/null; then
	    COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- $cur ) )
	else
	    # make do with /etc/passwd
	    COMPREPLY=( $( awk 'BEGIN {FS=":"} {if ($3 ~ /^'$cur'/) print $3}'\
			    /etc/passwd ) )
	fi
}

# This function completes on group IDs
#
_gids()
{
	if type getent &>/dev/null; then
	    COMPREPLY=( $( getent group | \
			    awk -F: '{if ($3 ~ /^'$cur'/) print $3}' ) )
	elif type perl &>/dev/null; then
	    COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- $cur ) )
	else
	    # make do with /etc/group
	    COMPREPLY=( $( awk 'BEGIN {FS=":"} {if ($3 ~ /^'$cur'/) print $3}'\
			    /etc/group ) )
	fi
}

# This function completes on services
#
_services()
{
	local sysvdir famdir
	[ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d
	famdir=/etc/xinetd.d
	COMPREPLY=( $( builtin echo $sysvdir/!(*.rpmsave|*.rpmorig|*~|functions)) )

	if [ -d $famdir ]; then
		COMPREPLY=( ${COMPREPLY[@]} $( builtin echo $famdir/!(*.rpmsave|*.rpmorig|*~)) )
	fi

	COMPREPLY=( $( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- $cur ) )
}

# This function complete on modules
#
_modules()
{
	local modpath
	modpath=/lib/modules/$1
	COMPREPLY=( $( command ls -R $modpath | \
			sed -ne 's/^\('$cur'.*\)\.k\?o\(\|.gz\)$/\1/p') )
}

# this function complete on user:group format
#
_usergroup()
{
	local IFS=$'\n'
	cur=${cur//\\\\ / }
	if [[ $cur = *@(\\:|.)* ]] && [ -n "$bash205" ]; then
		user=${cur%%*([^:.])}
		COMPREPLY=( $(compgen -P ${user/\\\\} -g -- ${cur##*[.:]}) )
	elif [[ $cur = *:* ]] && [ -n "$bash205" ]; then
		COMPREPLY=( $( compgen -g -- ${cur##*[.:]} ) )
	else
		COMPREPLY=( $( compgen -S : -u -- $cur ) )
	fi
}

# this function count the number of mandatory args
#
_count_args()
{
	args=1
	for (( i=1; i < COMP_CWORD; i++ )); do
		if [[ "${COMP_WORDS[i]}" != -* ]]; then
			args=$(($args+1))
		fi
	done
}


# Include completion files - if not already loaded.  Each directory in $COMP_PATH is
# examined for "./include/file"
# NOTE: Each file must have at least one function with the same name as the
#       filename.  This way `comp_include' can detect if a file already has been
#       included.  E.g. cd() should reside in file ./include/cd.
# @param $* string  Files to include
comp_include() {
    for s; do
        if ! declare -F "$s" &> /dev/null; then 
	        # Convert colon (:) separated string `COMP_PATH' to array `aPaths'
	    local dir OLDIFS=$IFS; IFS=:; local -a aPaths=($COMP_PATH); IFS=$OLDIFS
	    for dir in "${aPaths[@]}"; do
		[ -r "$dir/include/$s" ] && . "$dir/include/$s" && break
	    done
	fi
    done
} # comp_include()


# Install real completion
# See also: _comp_install()
# @param $* string  (optional) Arguments to use for completion.  Default is "-F _${BASH_ARGV[0]}"
comp_install() {
    local comp=${BASH_ARGV[0]##*/}  # ${..##*/}: strip up to and including last slash
    local dir="${BASH_ARGV[0]%/$comp}"  # Extract dir from completion

    _comp_install $comp "$dir" "$*"
} # comp_install()


# Install real completion
# NOTE: The default function of the original bash_completion is "_$command".
#       A less collision-prone default might be "_comp_$command", e.g.
#       `_comp_ssh' instead of `_ssh' -- FVu, Sat Apr  5 09:21:21 CEST 2008
# @param $1 string comp
# @param $2 string dir
# @param $* string  (optional) Arguments to use for completion.  Default is "-F _${BASH_ARGV[0]}"
_comp_install() {
    local comp=$1
    shift
    local dir="$1"
    shift
        # Don't install completion if 'comp_dir2args()' returns false
    if comp_dir2args "$dir"; then
        eval complete ${*:--F _$comp} $COMP_ARGS ${COMP_WORDS[0]}
    else
        complete -r $comp
    fi
    unset -v COMP_ARGS
} # _comp_install()
