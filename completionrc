#!/bin/bash

[ -n "${BASH_COMPLETION_DEBUG:-}" ] && set -v || set +v


# This function completes on group IDs
#
_gids()
{
	if type getent &>/dev/null; then
	    COMPREPLY=( $( getent group | \
			    awk -F: '{if ($3 ~ /^'$cur'/) print $3}' ) )
	elif type perl &>/dev/null; then
	    COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- $cur ) )
	else
	    # make do with /etc/group
	    COMPREPLY=( $( awk 'BEGIN {FS=":"} {if ($3 ~ /^'$cur'/) print $3}'\
			    /etc/group ) )
	fi
}

# This function completes on services
#
_services()
{
	local sysvdir famdir
	[ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d
	famdir=/etc/xinetd.d
	COMPREPLY=( $( builtin echo $sysvdir/!(*.rpmsave|*.rpmorig|*~|functions)) )

	if [ -d $famdir ]; then
		COMPREPLY=( ${COMPREPLY[@]} $( builtin echo $famdir/!(*.rpmsave|*.rpmorig|*~)) )
	fi

	COMPREPLY=( $( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- $cur ) )
}

# This function complete on modules
#
_modules()
{
	local modpath
	modpath=/lib/modules/$1
	COMPREPLY=( $( command ls -R $modpath | \
			sed -ne 's/^\('$cur'.*\)\.k\?o\(\|.gz\)$/\1/p') )
}

# this function complete on user:group format
#
_usergroup()
{
	local IFS=$'\n'
	cur=${cur//\\\\ / }
	if [[ $cur = *@(\\:|.)* ]] && [ -n "$bash205" ]; then
		user=${cur%%*([^:.])}
		COMPREPLY=( $(compgen -P ${user/\\\\} -g -- ${cur##*[.:]}) )
	elif [[ $cur = *:* ]] && [ -n "$bash205" ]; then
		COMPREPLY=( $( compgen -g -- ${cur##*[.:]} ) )
	else
		COMPREPLY=( $( compgen -S : -u -- $cur ) )
	fi
}

# this function count the number of mandatory args
#
_count_args()
{
	args=1
	for (( i=1; i < COMP_CWORD; i++ )); do
		if [[ "${COMP_WORDS[i]}" != -* ]]; then
			args=$(($args+1))
		fi
	done
}


# Include completion files - if not already loaded.  Each directory in $COMP_PATH is
# examined for "./include/file"
# NOTE: Each file must have at least one function with the same name as the
#       filename.  This way `comp_include' can detect if a file already has been
#       included.  E.g. cd() should reside in file ./include/cd.
# @param $* string  Files to include
comp_include() {
    for s; do
        if ! declare -F "$s" &> /dev/null; then 
	        # Convert colon (:) separated string `COMP_PATH' to array `aPaths'
	    local dir OLDIFS=$IFS; IFS=:; local -a aPaths=($COMP_PATH); IFS=$OLDIFS
	    for dir in "${aPaths[@]}"; do
		[ -r "$dir/include/$s" ] && . "$dir/include/$s" && break
	    done
	fi
    done
} # comp_include()


# Install real completion
# See also: _comp_install()
# @param $* string  (optional) Arguments to use for completion.  Default is "-F _${BASH_ARGV[0]}"
comp_install() {
    local comp=${BASH_ARGV[0]##*/}  # ${..##*/}: strip up to and including last slash
    local dir="${BASH_ARGV[0]%/$comp}"  # Extract dir from completion

    _comp_install $comp "$dir" "$*"
} # comp_install()


# Install real completion
# NOTE: The default function of the original bash_completion is "_$command".
#       A less collision-prone default might be "_comp_$command", e.g.
#       `_comp_ssh' instead of `_ssh' -- FVu, Sat Apr  5 09:21:21 CEST 2008
# @param $1 string comp
# @param $2 string dir
# @param $* string  (optional) Arguments to use for completion.  Default is "-F _${BASH_ARGV[0]}"
_comp_install() {
    local comp=$1
    shift
    local dir="$1"
    shift
        # Don't install completion if 'comp_dir2args()' returns false
    if comp_dir2args "$dir"; then
        eval complete ${*:--F _$comp} $COMP_ARGS ${COMP_WORDS[0]}
    else
        complete -r $comp
    fi
    unset -v COMP_ARGS
} # _comp_install()
