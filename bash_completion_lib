#-- bash_completion_lib -----------------------------------------------
# Programmable completion functions for bash 3.x.
#
# Copyright (C) Freddy Vulto <fvulto@gmail.com>
#
# Versions
# - 2008: This release.  Completions are split into separate files
# - 2006: Unsplit version written by Ian Macdonald <ian@caliban.org>
#         See: http://caliban.org/bash/
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
# MA  02110-1301, USA
#
# The latest version of this software can be obtained here:
# http://fvue.nl/wiki/Bash_completion_lib


    # Extended globbing and programmable completion have to be
    # set in order for completion to work
shopt -s extglob progcomp
compPwd="$PWD"

# If `COMP_CACHE' is defined and points to a writable file, completions will be
# read from this file.  Completions are stored in this file after the first run
# of `bash_completion_lib'.
#COMP_CACHE=$HOME/.bash_completion_lib~
    # Store current directory of this script
COMP_DIR=$(cd "$(dirname "$(which "${BASH_SOURCE-$0}")")" && /bin/pwd)
COMP_LIB="$COMP_DIR/completions"
COMP_RESTRICT_BY_EXTENSION=${COMP_RESTRICT_BY_EXTENSION:-0}  # True (1) if restricted completion is enabled, False (0, default) if not


# Load completion commands.
# The appropriate script from the `completions' directory will be loaded.
comp_load() {
        # Always load `comploadrc'
    . $COMP_DIR/comploadrc
        # Load `completionrc' once
    declare -F comp_install &> /dev/null || . $COMP_DIR/completionrc
        # Find completion script
        # NOTE: A search is performed for both `command' and `*.command'.
        #       Syntax `*.command' is a kind of symlink notation.  E.g.
        #       `make.gnumake' lets `make' handle the completion of `gnumake'.
        #       Symlinks are not used, because they're not available on every system.
        #       If a command ends with an exclamation mark (!), symlink notation is disabled.
        #       Variables: script = path/comp, comp = target | target.link
        # NOTE: Use 'tail -1' to get the last match in case 'find' returns more than one match
    local script="$(find "$COMP_LIB"/*/"${COMP_WORDS[0]}" "$COMP_LIB"/*/"${COMP_WORDS[0]}"! "$COMP_LIB"/*/*."${COMP_WORDS[0]}" 2> /dev/null | tail -1)"
    local comp=${script##*/}  # Remove path
        # Remove possible .link only if exclamation mark (!) isn't last character
    [[ ${comp: -1:1} == ! ]] || comp=${comp%.*}
    local path=${script%/*}   # Remove comp
        # Source completion of command to complete
    [ -r "$path/$comp" ] && . "$path/$comp"
        # Unset `comploadrc' variables
    unset -v bashdefault default dirnames filenames nospace plusdirs UNAME
} # comp_load()


# Convert directory to completion arguments.  If a directory starts with
# 'complete-', the file .complete will be included.  This file is supposed
# to set the global variable 'COMP_ARGS'.
# @param $1  Directory.  Must include at least one slash and start with "complete", e.g.:
#            ./complete -o nospace
#            /home/joe/completions/complete -o filenames
# @result exit  True (0) if completion must be installed, False (> 0) if
#     not.  Global 'COMP_ARGS' contains the arguments to pass to 'complete'
#     NOTE: Global 'COMP_ARGS' is used instead of echo-ing the string
#           to stdout, because this saves us invoking a subshell, thus
#           gains speed.
comp_dir2args() {
    COMP_ARGS=
    case "${1##*/}" in  # `${1##*/}' means: strip up to including last slash
        complete-*)
            [ -r "$1/.complete" ] && . "$1/.complete"
            ;;
        complete*)
            COMP_ARGS="${1##*/complete}"
            ;;
    esac
} # comp_dir2args()


    # Install completion for all files in `./completions/*'
 
	# Use cache if set
[ "$COMP_CACHE" ] && . "$COMP_CACHE" || {
    # No, cache isn't set or isn't available; load completions
	if cd "$COMP_LIB"; then
		compEnvShoptOptions=$(shopt -p dotglob failglob nullglob)
		shopt -s nullglob
		shopt -u dotglob failglob
		. $COMP_DIR/comploadrc
		# use GNU sed if we have it, since its extensions are still used in our code
		[ $UNAME != Linux ] && which gsed > /dev/null && alias sed=gsed
		for i in complete*; do
				# Don't install completion if 'comp_dir2args()' returns false
			if comp_dir2args "./$i"; then
				cd "$i" && {
					for comp in *; do
                            # If name ends with exclamation mark (!) only strip last exclamation mark,
                            # otherwise strip till first dot (*.)
						[[ ${comp: -1:1} == ! ]] && comp=${comp%!} || comp=${comp#*.}
						complete -F comp_load $COMP_ARGS $comp
					done
					cd ..
				}
			fi
		done
		    # If COMP_CACHE is unset, set COMP_CACHE.  
            # Generate cache file if COMP_CACHE not empty.
		[ "${COMP_CACHE=$HOME/.bash_completion_lib~}" ] && complete -p > "$COMP_CACHE"

		eval "$compEnvShoptOptions" 2> /dev/null  # Restore `shopt' options
			# Unset `comploadrc' variables
		unset -v bashdefault default dirnames filenames nospace plusdirs UNAME
		cd $compPwd > /dev/null
	fi
}
unset -v args comp COMP_ARGS compEnvShoptOptions compPwd i j
